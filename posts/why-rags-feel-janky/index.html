<!doctype html><html class="dark light"><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Why RAGs Feel Janky, Yet They Work
        
    </title><meta content="Why RAGs Feel Janky, Yet They Work" property=og:title><link href=/images/favicon.png rel=icon type=image/png><link href=/fonts.css rel=stylesheet><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=/atom.xml rel=alternate title=mayukh_chr type=application/atom+xml><link href=/theme/light.css rel=stylesheet><link href=/theme/dark.css id=darkModeStyle rel=stylesheet><link href=/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=/>mayukh_chr</a><div class=socials><a class=social href=https://github.com/mayukh-chr/ rel=me> <img alt=github src=/social_icons/github.svg> </a><a class=social href=https://www.linkedin.com/in/mayukh-chr/ rel=me> <img alt=linkedin src=/social_icons/linkedin.svg> </a><a href="https://open.spotify.com/user/zuumtdcue8fsfcq8owwju8i8x?si=8c3c8744363f4d95" class=social rel=me> <img alt=spotify src=/social_icons/spotify.svg> </a></div></div><nav><a href=/posts style=margin-left:.7em>/posts</a><a href=/projects style=margin-left:.7em>/projects</a><a href=/about style=margin-left:.7em>/about</a><a href=/cv.pdf style=margin-left:.7em>/CV</a> | <a href=javascript:void(0) id=dark-mode-toggle onclick=toggleTheme()> <img id=sun-icon src=/feather/sun.svg style=filter:invert(1)> <img id=moon-icon src=/feather/moon.svg> </a><script src=/js/themetoggle.js></script></nav></header><main><article><div class=title><div class=page-header>Why RAGs Feel Janky, Yet They Work<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2025-07-06</time></div></div><h1>Table of Contents</h1><ul><li><a href=/posts/why-rags-feel-janky/#introduction>Introduction</a><li><a href=/posts/why-rags-feel-janky/#the-surprising-simplicity-of-rag>The Surprising Simplicity of RAG</a><li><a href=/posts/why-rags-feel-janky/#why-this-janky-approach-actually-works>Why This "Janky" Approach Actually Works</a> <ul><li><a href=/posts/why-rags-feel-janky/#the-power-of-attention-mechanisms>The Power of Attention Mechanisms</a><li><a href=/posts/why-rags-feel-janky/#llms-as-universal-parsers>LLMs as Universal Parsers</a></ul><li><a href=/posts/why-rags-feel-janky/#when-simple-concatenation-falls-short>When Simple Concatenation Falls Short</a><li><a href=/posts/why-rags-feel-janky/#the-beauty-of-artificial-intelligence>The Beauty of Artificial Intelligence</a></ul><section class=body><h1 id=introduction>Introduction</h1><p>    After years of working in backend development, I recently dove back into the ML and LLM space to build <strong>Cravings</strong>, a lightweight RAG (Retrieval-Augmented Generation) chatbot that suggests recipes based on how you're feeling. Using Google Gemini API's free-tier Flash models, a Qdrant vector database hosted on GCP, FastEmbed for local text embedding, and a FastAPI backend, I was expecting something... more sophisticated under the hood. What I found instead was surprisingly simple: the retrieved data was just <strong>concatenated strings</strong> fed directly to the LLM. No fancy JSON protocols, no structured schemas, just plain text mashed together and handed off to the model.<p>    This revelation was both jarring and fascinating. Coming from a world where APIs communicate through carefully structured JSON payloads and databases return normalized data with clear schemas, seeing RAG systems work with what essentially amounts to "copy-paste" operations felt primitive. Yet, these systems are powering some of the most impressive AI applications we see today How can something so seemingly crude be so effective?<h1 id=the-surprising-simplicity-of-rag>The Surprising Simplicity of RAG</h1><p>    At its core, RAG works by retrieving relevant information from external sources and <strong>concatenating</strong> it as context with the original input prompt before feeding it to the text generator When I query Cravings about comfort food recipes, the system retrieves similar recipe chunks from the vector database, literally strings them together with some basic separators, and presents this concatenated mess to Gemini. No parsing, no structured data transformation—just raw text concatenation. <img alt=image1 async src=/images/p4/image2.png width=800px><p>    This approach initially struck me as inefficient. In traditional software systems, we spend enormous effort optimizing data structures, creating clean interfaces, and ensuring type safety. Yet here was a system that deliberately throws structured data out the window and relies on the LLM to make sense of unstructured text blobs.<h1 id=why-this-janky-approach-actually-works>Why This "Janky" Approach Actually Works</h1><p>    The effectiveness of concatenated strings in RAG systems stems from how Large Language Models process information. Unlike traditional programs that require explicit data structures and protocols, LLMs are fundamentally designed to understand and generate human language—which is inherently unstructured. They excel at extracting meaning from context, regardless of how that context is formatted.<h2 id=the-power-of-attention-mechanisms>The Power of Attention Mechanisms</h2><p>    After digging, I found that the answer lies in the <strong><a href=https://arxiv.org/pdf/1706.03762>attention mechanism</a></strong> thats present in the transformer-based LLMs. When an LLM processes concatenated text, it doesn't just read it sequentially like a traditional parser. Instead, it uses self-attention to dynamically focus on different parts of the input, assigning varying weights to each piece of information based on its relevance to the current task.<p><img alt=image1 async src=/images/p4/image1.png width=400px><p>    For example, when processing a prompt like "Context: Recipe for chocolate chip cookies... User Question: How do I make cookies chewy?", the attention mechanism allows the model to automatically identify and prioritize the relevant recipe steps related to texture while ignoring irrelevant details. This dynamic weighting happens at the token level, enabling the model to extract meaningful relationships even from seemingly messy concatenated text.<h2 id=llms-as-universal-parsers>LLMs as Universal Parsers</h2><p>    What makes this particularly elegant is that LLMs function as universal parsers. They've been trained on massive amounts of text data that includes everything from structured JSON to rambling forum posts, technical documentation to poetry. This training gives them an inherent ability to extract signal from noise, regardless of the input format.<p>    In essence, the "jankiness" of concatenated strings becomes irrelevant because the LLM has learned to parse human language in all its messy, unstructured glory. The model's robustness to noisy input is actually a feature, not a bug.<h1 id=when-simple-concatenation-falls-short>When Simple Concatenation Falls Short</h1><p>    While concatenated strings work remarkably well for many RAG applications, they're not without limitations. Research shows that LLMs can struggle with <a href=https://openreview.net/pdf/83ecbeacdc33fcabe475061cd51acfb4190ede33.pdf>deeply nested or highly structured data</a> when presented as plain text. Complex relationships between data points may be lost in translation, and the model's ability to maintain accuracy degrades when dealing with very long concatenated contexts.<p>    Additionally, the lack of explicit structure can make it difficult to trace how the model arrived at its conclusions, which is problematic for applications requiring explainability. Some advanced RAG systems are beginning to experiment with <strong>structured prompting</strong> techniques and <strong>special tokens</strong> to provide better guidance to the LLM about how to interpret different sections of the concatenated context.<h1 id=the-beauty-of-artificial-intelligence>The Beauty of Artificial Intelligence</h1><blockquote><p>If it works, it ain't broke</blockquote><p>    What initially felt like a hack is actually a proof to the intelligence of these systems. The ability to extract meaning from unstructured input mirrors how humans process information. We don't require data to be perfectly formatted to understand it; we use context, pattern recognition, and prior knowledge to make sense of messy, real-world information.<p>    RAG systems leverage this same capability. By feeding LLMs concatenated text that includes both the retrieved context and the user's question, we're essentially recreating the human experience of consulting multiple sources to answer a question. The "jankiness" disappears when we realize that the LLM's training has prepared it to handle exactly this type of unstructured input.</section></article></main></div>